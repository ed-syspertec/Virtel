%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}


\usepackage{cmap}

\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}

\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}




% Enable unicode and use Courier New to ensure the card suit
% characters that are part of the 'random' module examples
% appear properly in the PDF output.
\usepackage{fontspec}
\setmonofont{Courier New}


\title{Using VBA macros with Virtel}
\date{Jul 23, 2020}
\release{1.00}
\author{Syspertec Communications}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{TN201904::doc}}



\chapter{Introduction}
\label{\detokenize{TN201904:introduction}}
The following newsletter documents how we can use a VBA macro, driven by MicroSoft Excel, to populate a spreadsheet. From the spreadsheet we drive a Virtel Scenario to obtain a member list of a TSO ISPF Dataset and then populate the spreadsheet with the results. See the Installation section to install the necessary components.


\chapter{Installation}
\label{\detokenize{TN201904:installation}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Download the zip package from the Virtel FTP website - vbaexample.zip

\item {} 
Expand into a directory on your PC - C:MACRO     (This name is coded in the VBA macro)

\item {} 
Open the macro VBAExample.xlsm with Excel. Note: Enable Macros option when requested.

\item {} 
Upload the scenario source file VBAExample.vsc to HLQ.VIRTEL.CNTL as member TSTMACRO

\item {} 
Check the following MACLIB members in HLQ.VIRTEL.SCRNAPI.MACLIB
\begin{quote}

OPTION\$, FOREACH\$, COPY\$, CASE\$, ENDFOR\$

Search for any X’44’(è) characters and replace them with X’7C’ (UK/US @). If you do not do this, you will get assembly errors when complying the scenario.
\end{quote}

\item {} 
Upload and assemble the TSTMACRO scenario with the ASMSCEN member of the Virtel CNTL library and link the scenario to your HLQ.VIRTEL.LOADLIB.

\item {} 
Start Virtel

\item {} 
Check that your CLI 41002 line Entry Point loads scenarios from LOADLIB and not the SCE-DIR.
\begin{quote}

Go to the Admin Portal and display the CLIHOST Entry Point. Make sure the Directory for scenarios is blank. This will ensure that Virtel loads scenarios from the loadlib.
\end{quote}

\end{enumerate}

\sphinxincludegraphics{{image4}.png}
\sphinxstyleemphasis{Setting the scenario LOAD option in the Entry point}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{8}
\item {} 
Add the transaction CLI-12 to the CLIWHOST Entry point. Transaction CLI-12 is a 3270 based transaction directed towards a TSO session. It uses basic authentication (Security=1) and has an Input Scenario of TSTMACRO.

\end{enumerate}

\sphinxincludegraphics{{image5}.png}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{9}
\item {} 
Stop and restart Virtel.

\end{enumerate}


\chapter{Operation}
\label{\detokenize{TN201904:operation}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Open the the EXCEL macro VBAExample.xlsm. The following form is presented: -

\end{enumerate}

\sphinxincludegraphics{{image1}.png}
\sphinxstyleemphasis{Excel Form}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{1}
\item {} 
The form presents us with several controls that can be used to drive the HTTP requests between the VBA macro and Virtel.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{USER}\PYG{p}{:}\PYG{o}{/}\PYG{n}{PASS}\PYG{p}{:}                     \PYG{n}{The} \PYG{n}{userid} \PYG{o+ow}{and} \PYG{n}{password}\PYG{o}{.}
\PYG{n}{Show} \PYG{n}{full} \PYG{n}{URL}\PYG{p}{:}            \PYG{n}{Revals} \PYG{n}{the} \PYG{n}{URL} \PYG{n}{that} \PYG{o+ow}{is} \PYG{n}{passed} \PYG{n}{to} \PYG{n}{Virtel}
\PYG{n}{Virtel} \PYG{n}{Host} \PYG{o}{/} \PYG{n}{Port}\PYG{p}{:}       \PYG{n}{The} \PYG{n}{target} \PYG{n}{Virtel} \PYG{n}{Host} \PYG{o+ow}{and} \PYG{n}{Port}
\PYG{n}{DS} \PYG{n}{Name}\PYG{p}{:}                \PYG{n}{The} \PYG{n}{Mainframe} \PYG{n}{Dataset} \PYG{n}{name}
\PYG{n}{Additional} \PYG{n}{URL} \PYG{n}{Parms}\PYG{o}{.}     \PYG{n}{Keyword}\PYG{p}{:}\PYG{n}{Value} \PYG{n}{combinations} \PYG{n}{that} \PYG{n}{can} \PYG{n}{be} \PYG{n}{passed} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{URL}\PYG{o}{.}
\PYG{n}{Request} \PYG{n}{HTTP}\PYG{p}{:}           \PYG{n}{Button} \PYG{n}{to} \PYG{n}{initiate} \PYG{n}{the} \PYG{n}{request}
\PYG{n}{Clear} \PYG{n}{Results}\PYG{p}{:}          \PYG{n}{Clear} \PYG{n}{the} \PYG{n}{template} \PYG{n}{result} \PYG{n}{area}
\end{sphinxVerbatim}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{2}
\item {} 
Fill in the required details:-

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{USER}\PYG{p}{:}             \PYG{n}{Your} \PYG{n}{userid}
\PYG{n}{PASS}\PYG{p}{:}             \PYG{n}{Your} \PYG{n}{password}
\PYG{n}{Virtel} \PYG{n}{Host}\PYG{p}{:}      \PYG{n}{IP} \PYG{n}{address} \PYG{n}{of} \PYG{n}{Virtel}
\PYG{n}{Virtel} \PYG{n}{Port}\PYG{p}{:}      \PYG{l+m+mi}{41002}
\PYG{n}{DS} \PYG{n}{Name}\PYG{p}{:}          \PYG{n}{Name} \PYG{n}{of} \PYG{n}{PDS} \PYG{n}{to} \PYG{n+nb}{list}
\end{sphinxVerbatim}

From these details, the VBA macro will generate a URL that will be used to initiate the TSTMACRO transaction. The generated URL looks like.

\sphinxincludegraphics{{image2}.png}

\sphinxstyleemphasis{URL genereted from the EXCEL macro}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{3}
\item {} 
Press the HTTP request button to initiate the transaction. After the transaction has completed the form will be populated with a member list. The final results look like: -

\end{enumerate}

\sphinxincludegraphics{{image3}.png}


\chapter{Appendix A}
\label{\detokenize{TN201904:appendix-a}}

\section{VBA Example Scenario}
\label{\detokenize{TN201904:vba-example-scenario}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
TSTMACRO SCREENS APPL=TSTMACRO
*\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
*\PYGZsh{}\PYGZsh{}                         INPUT SCENARIO                           \PYGZsh{}\PYGZsh{}
*\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
*
   SCENARIO INPUT
   DEBUG\PYGZdl{} TRACE,SCENARIO
*
   COPY\PYGZdl{} INPUT\PYGZhy{}TO\PYGZhy{}VARIABLE,FIELD=\PYGZsq{}userName\PYGZsq{},VAR=\PYGZsq{}userName\PYGZsq{}
   IF\PYGZdl{}   NOT\PYGZhy{}FOUND,THEN=PARAM\PYGZus{}ERR\PYGZus{}USER
   COPY\PYGZdl{} INPUT\PYGZhy{}TO\PYGZhy{}VARIABLE,FIELD=\PYGZsq{}password\PYGZsq{},VAR=\PYGZsq{}password\PYGZsq{}
   IF\PYGZdl{}   NOT\PYGZhy{}FOUND,THEN=PARAM\PYGZus{}ERR\PYGZus{}PWD
   COPY\PYGZdl{} INPUT\PYGZhy{}TO\PYGZhy{}VARIABLE,FIELD=\PYGZsq{}dsname\PYGZsq{},VAR=\PYGZsq{}dsname\PYGZsq{}
   IF\PYGZdl{}   NOT\PYGZhy{}FOUND,THEN=PARAM\PYGZus{}ERR\PYGZus{}DSNAME,ELSE=LOGON
*
PARAM\PYGZus{}ERR\PYGZus{}USER EQU *
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=ErrorMsg,TYPE=REPLACE,            *
         VALUE=\PYGZsq{}Missing required parameter (userName)\PYGZsq{}

   GOTO\PYGZdl{} ERRORMSG
*
PARAM\PYGZus{}ERR\PYGZus{}PWD EQU   *
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=ErrorMsg,TYPE=REPLACE,            *
         VALUE=\PYGZsq{}Missing required parameter (password)\PYGZsq{}
   GOTO\PYGZdl{} ERRORMSG
*
PARAM\PYGZus{}ERR\PYGZus{}DSNAME EQU   *
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=ErrorMsg,TYPE=REPLACE,            *
         VALUE=\PYGZsq{}Missing required parameter (dsname)\PYGZsq{}
   GOTO\PYGZdl{} ERRORMSG
*
LOGON    EQU   *
   ERROR\PYGZdl{} 0,\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{} LOGON \PYGZsq{}
*
   CASE\PYGZdl{} (01,12,12),                                             *
         (EQ,\PYGZsq{}ENTER USERID\PYGZsq{},DOUSN)
*
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VALUE=\PYGZsq{}Not (UserID Logon) Screen\PYGZsq{},    *
         VAR=ErrorMsg,TYPE=REPLACE
   GOTO\PYGZdl{} ERRORMSG\PYGZus{}WITH\PYGZus{}SCREEN
*
DOUSN    EQU   *
   ERROR\PYGZdl{} 0,\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{} DOUSN\PYGZsq{}
*
   ERROR\PYGZdl{} 0,\PYGZsq{}userName=\PYGZsq{},\PYGZsq{}*userName\PYGZsq{}
   COPY\PYGZdl{} VARIABLE\PYGZhy{}TO\PYGZhy{}SCREEN,VAR=\PYGZsq{}userName\PYGZsq{},                      *
         SCREEN=(2,1,7),TYPE=ERASE\PYGZhy{}FIELD
   ACTION\PYGZdl{}  TO\PYGZhy{}APPLICATION,KEY=7D,                               *
         AND=(PROCESS\PYGZhy{}RESPONSE)
*
   IF\PYGZdl{} (01,34,11),                                               *
         EQ=\PYGZsq{}TSO/E LOGON\PYGZsq{},                                       *
         THEN=DOPASS
*
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VALUE=\PYGZsq{}Not (TSO Logon) Screen\PYGZsq{},       *
         VAR=ErrorMsg,TYPE=REPLACE
   GOTO\PYGZdl{} ERRORMSG\PYGZus{}WITH\PYGZus{}SCREEN
*
DOPASS   EQU   *
   ERROR\PYGZdl{} 0,\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{} DOPASS\PYGZsq{}
*
   ERROR\PYGZdl{} 0,\PYGZsq{}password=\PYGZsq{},\PYGZsq{}*password\PYGZsq{}
   COPY\PYGZdl{} VARIABLE\PYGZhy{}TO\PYGZhy{}SCREEN,VAR=\PYGZsq{}password\PYGZsq{},                      *
         SCREEN=(8,20,8),TYPE=ERASE\PYGZhy{}FIELD
DOISPF   LABEL\PYGZdl{}
   ACTION\PYGZdl{}  TO\PYGZhy{}APPLICATION,KEY=7D,                               *
         AND=(WAIT,\PYGZsq{}ispf\PYGZsq{}),                                      *
         MAXTIME=500
*
   ERROR\PYGZdl{} 0,\PYGZsq{}Look for ISPF in line 10\PYGZsq{}
   IF\PYGZdl{} (10,2,4),                                                 *
         EQ=\PYGZsq{}ispf\PYGZsq{},                                              *
         THEN=PASSDONE
   ERROR\PYGZdl{} 0,\PYGZsq{}Look for ISPF in line 11\PYGZsq{}
   IF\PYGZdl{} (11,2,4),                                                 *
         EQ=\PYGZsq{}ispf\PYGZsq{},                                              *
         THEN=PASSDONE
   ERROR\PYGZdl{} 0,\PYGZsq{}Look for ISPF in line 12\PYGZsq{}
   IF\PYGZdl{} (12,2,4),                                                 *
         EQ=\PYGZsq{}ispf\PYGZsq{},                                              *
         THEN=PASSDONE
   ERROR\PYGZdl{} 0,\PYGZsq{}Look for ISPF in line 13\PYGZsq{}
   IF\PYGZdl{} (13,2,4),                                                 *
         EQ=\PYGZsq{}ispf\PYGZsq{},                                              *
         THEN=PASSDONE
*
* Check for common login errors
*
   IF\PYGZdl{} (2,12,17),                                                *
         EQ=\PYGZsq{}PASSWORD NOT AUTH\PYGZsq{},                                 *
         THEN=LOGON\PYGZus{}BADPASS
   IF\PYGZdl{} (2,12,6),                                                 *
         EQ=\PYGZsq{}Userid\PYGZsq{},                                            *
         THEN=LOGON\PYGZus{}BADUSER\PYGZus{}MAYBE
*
* Generic login error message
*
LOGON\PYGZus{}GENERIC EQU *
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}ErrorMsg\PYGZsq{},TYPE=REPLACE,          *
         VALUE=\PYGZsq{}ISPF screen not found (Is the user logged in?)\PYGZsq{}
   GOTO\PYGZdl{} ERRORMSG\PYGZus{}WITH\PYGZus{}SCREEN
*
LOGON\PYGZus{}BADUSER\PYGZus{}MAYBE EQU *
   IF\PYGZdl{} (2,27,8),                                                 *
         EQ=\PYGZsq{}not auth\PYGZsq{},                                          *
         THEN=LOGON\PYGZus{}BADUSER,                                     *
         ELSE=LOGON\PYGZus{}GENERIC
*
* Invalid User
*
LOGON\PYGZus{}BADUSER EQU *
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}ErrorMsg\PYGZsq{},TYPE=REPLACE,          *
         VALUE=\PYGZsq{}Login failed (Invalid User)\PYGZsq{}
   GOTO\PYGZdl{} ERRORMSG\PYGZus{}WITH\PYGZus{}SCREEN
*
* Invalid Password
*
LOGON\PYGZus{}BADPASS EQU *
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}ErrorMsg\PYGZsq{},TYPE=REPLACE,          *
         VALUE=\PYGZsq{}Login failed (Invalid Password)\PYGZsq{}
   GOTO\PYGZdl{} ERRORMSG\PYGZus{}WITH\PYGZus{}SCREEN
*
PASSDONE EQU   *
   ERROR\PYGZdl{} 0,\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{} PASSDONE\PYGZsq{}
*
   ACTION\PYGZdl{}  TO\PYGZhy{}APPLICATION,KEY=7D,                               *
         AND=(PROCESS\PYGZhy{}RESPONSE)
   IF\PYGZdl{} (3,29,12),                                                *
         EQ=\PYGZsq{}ISPF Primary\PYGZsq{},                                      *
         THEN=DOOPTION
*
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VALUE=\PYGZsq{}Not (Primary Menu) screen\PYGZsq{},    *
         VAR=ErrorMsg,TYPE=REPLACE
   GOTO\PYGZdl{} ERRORMSG\PYGZus{}WITH\PYGZus{}SCREEN
*
DOOPTION EQU *
*
   ERROR\PYGZdl{} 0,\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{} DOOPTION\PYGZsq{}
*
   ERROR\PYGZdl{} 0,\PYGZsq{}Sending (=3.4)\PYGZsq{}
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VALUE=\PYGZsq{}=3.4\PYGZsq{},                         *
         VAR=\PYGZsq{}input\PYGZsq{},TYPE=REPLACE
   COPY\PYGZdl{} VARIABLE\PYGZhy{}TO\PYGZhy{}SCREEN,VAR=\PYGZsq{}input\PYGZsq{},                         *
         SCREEN=(4,40,4),TYPE=ERASE\PYGZhy{}FIELD
   ACTION\PYGZdl{} TO\PYGZhy{}APPLICATION,KEY=7D,                                *
         AND=(PROCESS\PYGZhy{}RESPONSE)
   IF\PYGZdl{} (3,30,13),                                                *
         EQ=\PYGZsq{}Data Set List\PYGZsq{},                                     *
         THEN=DODATASET
*
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VALUE=\PYGZsq{}Not (DataSet Menu) screen\PYGZsq{},    *
         VAR=ErrorMsg,TYPE=REPLACE
   GOTO\PYGZdl{} ERRORMSG\PYGZus{}WITH\PYGZus{}SCREEN
*
DODATASET EQU *
*
   ERROR\PYGZdl{} 0,\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{} DODATASET\PYGZsq{}
*
   ERROR\PYGZdl{} 0,\PYGZsq{}Sending Dsname (\PYGZsq{},\PYGZsq{}*dsname\PYGZsq{},\PYGZsq{})\PYGZsq{}
   COPY\PYGZdl{} VARIABLE\PYGZhy{}TO\PYGZhy{}SCREEN,VAR=\PYGZsq{}dsname\PYGZsq{},                        *
         SCREEN=(10,24,46),TYPE=ERASE\PYGZhy{}FIELD
   ACTION\PYGZdl{} TO\PYGZhy{}APPLICATION,KEY=7D,                                *
         AND=(PROCESS\PYGZhy{}RESPONSE)
   IF\PYGZdl{} (3,16,13),                                                *
         EQ=\PYGZsq{}Sets Matching\PYGZsq{},                                     *
         THEN=DOCONTENT
*
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VALUE=\PYGZsq{}Not (DataSet Match) screen\PYGZsq{},   *
         VAR=ErrorMsg,TYPE=REPLACE
   GOTO\PYGZdl{} ERRORMSG\PYGZus{}WITH\PYGZus{}SCREEN
*
DOCONTENT EQU *
*
   ERROR\PYGZdl{} 0,\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{} DOCONTENT\PYGZsq{}
*
   ERROR\PYGZdl{} 0,\PYGZsq{}Sending (E)\PYGZsq{}
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VALUE=\PYGZsq{}e\PYGZsq{},VAR=\PYGZsq{}input\PYGZsq{},TYPE=REPLACE

   COPY\PYGZdl{} VARIABLE\PYGZhy{}TO\PYGZhy{}SCREEN,VAR=\PYGZsq{}input\PYGZsq{},                         *
         SCREEN=(8,28,1),TYPE=ERASE\PYGZhy{}FIELD
   ACTION\PYGZdl{} TO\PYGZhy{}APPLICATION,KEY=7D,                                *
         AND=(PROCESS\PYGZhy{}RESPONSE)
*
   COPY\PYGZdl{} SCREEN\PYGZhy{}TO\PYGZhy{}VARIABLE,SCREEN=(06,12,69,17),VAR=\PYGZsq{}lines\PYGZsq{},    X
         TYPE=REPLACE
   ERROR\PYGZdl{} 0,\PYGZsq{}Setting lines \PYGZsq{},\PYGZsq{}*lines\PYGZsq{}


   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},VALUE=\PYGZsq{}OK:\PYGZsq{},           X
         TYPE=REPLACE
   GOTO\PYGZdl{} APPEND\PYGZus{}SCREEN
*
LOGOFF   EQU   *
   ERROR\PYGZdl{} 0,\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{} DOLOGOFF\PYGZsq{}
*
   CASE\PYGZdl{} (04,02,07),(EQ,\PYGZsq{}Command\PYGZsq{},DOLOGOFF)
   ERROR\PYGZdl{} 0,\PYGZsq{}Not logged \PYGZhy{} Skipping logoff\PYGZsq{}
   GOTO\PYGZdl{} RETURN\PYGZus{}RESPONSE
*
DOLOGOFF LABEL\PYGZdl{}
   ERROR\PYGZdl{} 0,\PYGZsq{}Sending (=X)\PYGZsq{}
   PERFORM\PYGZdl{} TRACE
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VALUE=\PYGZsq{}=X\PYGZsq{},                           *
         VAR=\PYGZsq{}clear\PYGZsq{},TYPE=REPLACE
   COPY\PYGZdl{} VARIABLE\PYGZhy{}TO\PYGZhy{}SCREEN,VAR=\PYGZsq{}clear\PYGZsq{},                         *
         SCREEN=(4,40,2),TYPE=ERASE\PYGZhy{}FIELD
   ACTION\PYGZdl{}  TO\PYGZhy{}APPLICATION,KEY=7D,                               *
         AND=(WAIT,\PYGZsq{}READY\PYGZsq{}),                                     *
         MAXTIME=500
*
   ERROR\PYGZdl{} 0,\PYGZsq{}Sending (LOGOFF)\PYGZsq{}
   PERFORM\PYGZdl{} TRACE
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VALUE=\PYGZsq{}LOGOFF\PYGZsq{},                       *
         VAR=\PYGZsq{}logoff\PYGZsq{},TYPE=REPLACE
   COPY\PYGZdl{} VARIABLE\PYGZhy{}TO\PYGZhy{}SCREEN,VAR=\PYGZsq{}logoff\PYGZsq{},                        *
         SCREEN=(2,2,6),TYPE=ERASE\PYGZhy{}FIELD
   ACTION\PYGZdl{}  TO\PYGZhy{}APPLICATION,KEY=7D,                               *
         AND=(WAIT,\PYGZsq{}LOGGED OFF\PYGZsq{}),                                *
         MAXTIME=5000
   PERFORM\PYGZdl{} TRACE
*
   ERROR\PYGZdl{} 0,\PYGZsq{}User Logged Off\PYGZsq{}
   GOTO\PYGZdl{} RETURN\PYGZus{}RESPONSE
*
*
*
*\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
*\PYGZsh{}\PYGZsh{}                          H E L P E R S                           \PYGZsh{}\PYGZsh{}
*\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
*
ERRORMSG EQU   *
   ERROR\PYGZdl{} 0,\PYGZsq{}*ErrorMsg\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},TYPE=REPLACE,           *
         LIST=(\PYGZsq{}KO:\PYGZsq{},\PYGZsq{}*ErrorMsg\PYGZsq{})
   GOTO\PYGZdl{} RETURN\PYGZus{}RESPONSE
*
ERRORMSG\PYGZus{}WITH\PYGZus{}SCREEN EQU *
   ERROR\PYGZdl{} 0,\PYGZsq{}*ErrorMsg\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},TYPE=REPLACE,           *
         LIST=(\PYGZsq{}KO:\PYGZsq{},\PYGZsq{}*ErrorMsg\PYGZsq{})
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},VALUE=\PYGZsq{}(*SCREEN*)\PYGZsq{}
*
APPEND\PYGZus{}SCREEN  EQU *
*
**Only 17 lines were read
*
   ERROR\PYGZdl{} 0,\PYGZsq{}Setting screen to response\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},LIST=(\PYGZsq{}01:\PYGZsq{},\PYGZsq{}*lines\PYGZsq{})
   POP\PYGZdl{} FIRST\PYGZhy{}VALUE\PYGZhy{}OF,VAR=\PYGZsq{}lines\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},LIST=(\PYGZsq{}02:\PYGZsq{},\PYGZsq{}*lines\PYGZsq{})
   POP\PYGZdl{} FIRST\PYGZhy{}VALUE\PYGZhy{}OF,VAR=\PYGZsq{}lines\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},LIST=(\PYGZsq{}03:\PYGZsq{},\PYGZsq{}*lines\PYGZsq{})
   POP\PYGZdl{} FIRST\PYGZhy{}VALUE\PYGZhy{}OF,VAR=\PYGZsq{}lines\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},LIST=(\PYGZsq{}04:\PYGZsq{},\PYGZsq{}*lines\PYGZsq{})
   POP\PYGZdl{} FIRST\PYGZhy{}VALUE\PYGZhy{}OF,VAR=\PYGZsq{}lines\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},LIST=(\PYGZsq{}05:\PYGZsq{},\PYGZsq{}*lines\PYGZsq{})
   POP\PYGZdl{} FIRST\PYGZhy{}VALUE\PYGZhy{}OF,VAR=\PYGZsq{}lines\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},LIST=(\PYGZsq{}06:\PYGZsq{},\PYGZsq{}*lines\PYGZsq{})
   POP\PYGZdl{} FIRST\PYGZhy{}VALUE\PYGZhy{}OF,VAR=\PYGZsq{}lines\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},LIST=(\PYGZsq{}07:\PYGZsq{},\PYGZsq{}*lines\PYGZsq{})
   POP\PYGZdl{} FIRST\PYGZhy{}VALUE\PYGZhy{}OF,VAR=\PYGZsq{}lines\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},LIST=(\PYGZsq{}08:\PYGZsq{},\PYGZsq{}*lines\PYGZsq{})
   POP\PYGZdl{} FIRST\PYGZhy{}VALUE\PYGZhy{}OF,VAR=\PYGZsq{}lines\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},LIST=(\PYGZsq{}09:\PYGZsq{},\PYGZsq{}*lines\PYGZsq{})
   POP\PYGZdl{} FIRST\PYGZhy{}VALUE\PYGZhy{}OF,VAR=\PYGZsq{}lines\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},LIST=(\PYGZsq{}10:\PYGZsq{},\PYGZsq{}*lines\PYGZsq{})
   POP\PYGZdl{} FIRST\PYGZhy{}VALUE\PYGZhy{}OF,VAR=\PYGZsq{}lines\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},LIST=(\PYGZsq{}11:\PYGZsq{},\PYGZsq{}*lines\PYGZsq{})
   POP\PYGZdl{} FIRST\PYGZhy{}VALUE\PYGZhy{}OF,VAR=\PYGZsq{}lines\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},LIST=(\PYGZsq{}12:\PYGZsq{},\PYGZsq{}*lines\PYGZsq{})
   POP\PYGZdl{} FIRST\PYGZhy{}VALUE\PYGZhy{}OF,VAR=\PYGZsq{}lines\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},LIST=(\PYGZsq{}13:\PYGZsq{},\PYGZsq{}*lines\PYGZsq{})
   POP\PYGZdl{} FIRST\PYGZhy{}VALUE\PYGZhy{}OF,VAR=\PYGZsq{}lines\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},LIST=(\PYGZsq{}14:\PYGZsq{},\PYGZsq{}*lines\PYGZsq{})
   POP\PYGZdl{} FIRST\PYGZhy{}VALUE\PYGZhy{}OF,VAR=\PYGZsq{}lines\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},LIST=(\PYGZsq{}15:\PYGZsq{},\PYGZsq{}*lines\PYGZsq{})
   POP\PYGZdl{} FIRST\PYGZhy{}VALUE\PYGZhy{}OF,VAR=\PYGZsq{}lines\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},LIST=(\PYGZsq{}16:\PYGZsq{},\PYGZsq{}*lines\PYGZsq{})
   POP\PYGZdl{} FIRST\PYGZhy{}VALUE\PYGZhy{}OF,VAR=\PYGZsq{}lines\PYGZsq{}
   COPY\PYGZdl{} LIST\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{},LIST=(\PYGZsq{}17:\PYGZsq{},\PYGZsq{}*lines\PYGZsq{})
   POP\PYGZdl{} FIRST\PYGZhy{}VALUE\PYGZhy{}OF,VAR=\PYGZsq{}lines\PYGZsq{}
*
LOOP1    FOREACH\PYGZdl{} VALUE\PYGZhy{}IN\PYGZhy{}VARIABLE,VAR=\PYGZsq{}response\PYGZsq{}
   COPY\PYGZdl{} VARIABLE\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=(\PYGZsq{}response\PYGZsq{},\PYGZsq{}VAR2\PYGZsq{}),           X
         FOREACH=LOOP1,TYPE=REPLACE
         ENDFOR\PYGZdl{} LOOP1

   GOTO\PYGZdl{} LOGOFF
*
RETURN\PYGZus{}RESPONSE EQU *
   ERROR\PYGZdl{} 0,\PYGZsq{}Returning response\PYGZsq{}
   CONVERT\PYGZdl{} EBCDIC\PYGZhy{}TO\PYGZhy{}ASCII,VAR=\PYGZsq{}response\PYGZsq{},TABLE=\PYGZsq{}IBM1147\PYGZsq{}
   SEND\PYGZdl{} AS\PYGZhy{}ANSWER,VAR=\PYGZsq{}response\PYGZsq{},TYPE=\PYGZsq{}text/plain\PYGZsq{},             *
         EXPIRES=IMMEDIATELY
   DEBUG\PYGZdl{} NOTRACE,SCENARIO
*
   SCENARIO END
*
*\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
*\PYGZsh{}\PYGZsh{}                        OUTPUT SCENARIO                           \PYGZsh{}\PYGZsh{}
*\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
*
   SCENARIO OUTPUT
   SCENARIO END
*
*****************
***   TRACE   ***
*****************
*
TRACE    SCENARIO SUBROUTINE
*
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}ruler1\PYGZsq{},                         X
         VALUE=\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  0\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 10\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 20\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 30\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 40\PYGZhy{}\PYGZhy{}\PYGZhy{}X
         \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 50\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 60\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 70\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 80\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZsq{},             X
         TYPE=REPLACE
   COPY\PYGZdl{} VALUE\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}ruler2\PYGZsq{},                         X
         VALUE=\PYGZsq{}123456789\textbar{}123456789\textbar{}123456789\textbar{}123456789\textbar{}123456789X
         \textbar{}123456789\textbar{}123456789\textbar{}123456789\textbar{}123456789\textbar{}\PYGZsq{},             X
         TYPE=REPLACE
   ERROR\PYGZdl{} 0,\PYGZsq{}          \PYGZsq{},\PYGZsq{}*ruler1\PYGZsq{}
   ERROR\PYGZdl{} 0,\PYGZsq{}          \PYGZsq{},\PYGZsq{}*ruler2\PYGZsq{}

LOOP1    FOREACH\PYGZdl{} VALUE\PYGZhy{}IN\PYGZhy{}SCREEN,SCREEN=(1,1,80,24)
   COPY\PYGZdl{} SCREEN\PYGZhy{}TO\PYGZhy{}VARIABLE,SCREEN=(=,01,80),VAR=\PYGZsq{}screenL\PYGZsq{},      X
         TYPE=REPLACE
   COPY\PYGZdl{} SYSTEM\PYGZhy{}TO\PYGZhy{}VARIABLE,VAR=\PYGZsq{}L1\PYGZsq{},LENGTH=2,                   *
         FIELD=(VALUE\PYGZhy{}OF,CURRENT\PYGZhy{}LINE),TYPE=REPLACE
   ERROR\PYGZdl{} 0,\PYGZsq{}line \PYGZsq{},\PYGZsq{}*L1\PYGZsq{},\PYGZsq{}== \PYGZsq{},\PYGZsq{}*screenL\PYGZsq{}
   ENDFOR\PYGZdl{} LOOP1
*
ENDTRACE LABEL\PYGZdl{}
   POP\PYGZdl{} VAR=\PYGZsq{}screenL\PYGZsq{}
   SCENARIO END
   SCRNEND
*
   END
\end{sphinxVerbatim}


\chapter{Appendix B}
\label{\detokenize{TN201904:appendix-b}}

\section{VBA Macro}
\label{\detokenize{TN201904:vba-macro}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}==========================================================================
\PYGZsq{}==========================================================================
\PYGZsq{}
\PYGZsq{}   Top\PYGZhy{}level MACROS for Excel
\PYGZsq{}
\PYGZsq{}==========================================================================
\PYGZsq{}==========================================================================

\PYGZsq{} \PYGZhy{} MACRO \PYGZhy{}
\PYGZsq{} \PYGZgt{} Performs a POST HTTP request on the generated URL,
\PYGZsq{} \PYGZgt{} Extracts data from the received content (if successful),
\PYGZsq{} \PYGZgt{} Injects the extracted data into the sheet \PYGZsq{}output\PYGZsq{} cells
\PYGZsq{}
Sub ProcessHTTP()
      Dim baseURL As String
      Dim prms As String
      Dim body As String
      Dim url As String
      Dim content As String
      Dim usrName As String
      Dim usrPass As String

      Call ResetResults
      Call ClearScreen

      \PYGZsq{} Gather miscellaneous pieces of information from the active sheet
      usrName = ActiveSheet.Range(g\PYGZus{}userNameRange).Value
      usrPass = ActiveSheet.Range(g\PYGZus{}userPassRange).Value
      baseURL = buildBaseUrl(g\PYGZus{}baseUrl)
      prms = buildUrlParams(g\PYGZus{}urlParamsRange)
      url = buildURL(baseURL, prms)
      body = \PYGZdq{}\PYGZdq{}

      \PYGZsq{} Send the HTTP request, and get back the received content
      content = sendHttpRequest(url, , body, usrName, usrPass)

      \PYGZsq{} Handle the HTTP response if no error occured
      If (content \PYGZlt{}\PYGZgt{} \PYGZdq{}\PYGZdq{}) Then
            handleHttpResponse (content)
      End If
End Sub


\PYGZsq{} \PYGZhy{} MACRO \PYGZhy{}
\PYGZsq{} Clear the result cells
\PYGZsq{}
Sub ResetResults()
      Call clearCells(g\PYGZus{}responseRange, g\PYGZus{}responseCols)
End Sub


\PYGZsq{} \PYGZhy{} MACRO \PYGZhy{} [DEBUG] \PYGZhy{}
\PYGZsq{} Displays the generated URL
\PYGZsq{}
Sub ShowURL()

      Dim url As String
      Dim res As String

      url = buildURL(buildBaseUrl(g\PYGZus{}baseUrl), buildUrlParams(g\PYGZus{}urlParamsRange))
      res = \PYGZdq{}The generated URL is :\PYGZdq{} \PYGZam{} vbCrLf \PYGZam{} vbCrLf \PYGZam{} \PYGZdq{}[\PYGZdq{} \PYGZam{} url \PYGZam{} \PYGZdq{}]\PYGZdq{}
      MsgBox res
End Sub

\PYGZsq{}=============================================================================
\PYGZsq{}=============================================================================
\PYGZsq{}
\PYGZsq{}   Functions and subs
\PYGZsq{}
\PYGZsq{}=============================================================================
\PYGZsq{}=============================================================================

\PYGZsq{} Extract the meaningful data lines from the received body, and store them into
\PYGZsq{} the output lines array. This array size is dynamically adjusted to hold any amount of entries.
\PYGZsq{} The last entry in this array is always followed by an empty marker entry.
\PYGZsq{}
Function extractDataFromResponse(ByVal content As String, ByRef lines() As String) As Long

      ReDim lines(17)
      Dim nbLines As Long
      Dim startIdx As Long
      Dim nextIdx As Long
      Dim stopIdx As Long
      Dim line As String

      startIdx = 4
      nbLines = 0

      Do
            line = Trim(Mid(content, startIdx, startIdx + 69))
            lines(nbLines) = line
            nbLines = nbLines + 1
            startIdx = startIdx + 69 + 3
      Loop While (nbLines \PYGZlt{} 17)

      extractDataFromResponse = nbLines
End Function


\PYGZsq{} Perform a synchronous HTTP request on the specified URL (using the specified body)
\PYGZsq{} If an error occurs, this function returns an empty string.
\PYGZsq{} Otherwise, it returns the body as recieved from the host.
\PYGZsq{}
Function sendHttpRequest(ByVal url As String, \PYGZus{}
      Optional ByVal mode As String = \PYGZdq{}POST\PYGZdq{}, \PYGZus{}
      Optional ByVal body As String = \PYGZdq{}\PYGZdq{}, \PYGZus{}
      Optional ByVal userName As String = \PYGZdq{}\PYGZdq{}, \PYGZus{}
      Optional ByVal password As String = \PYGZdq{}\PYGZdq{}) As String

      If (g\PYGZus{}DEBUG\PYGZus{}IN) Then
            Call MsgBox(url \PYGZam{} vbCrLf \PYGZam{} vbCrLf \PYGZam{} body, vbOKOnly, \PYGZdq{}HTTP Request\PYGZdq{})
      End If

      Dim http As Object
      Set http = CreateObject(\PYGZdq{}MSXML2.XMLHTTP\PYGZdq{})

      http.Open mode, url, False, userName, password
      http.setRequestHeader \PYGZdq{}User\PYGZhy{}Agent\PYGZdq{}, \PYGZdq{}Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)\PYGZdq{}
      \PYGZsq{}   http.setRequestHeader \PYGZdq{}Content\PYGZhy{}type\PYGZdq{}, \PYGZdq{}application/x\PYGZhy{}www\PYGZhy{}form\PYGZhy{}urlencoded\PYGZdq{}
      http.setRequestHeader \PYGZdq{}Content\PYGZhy{}type\PYGZdq{}, \PYGZdq{}text/plain\PYGZdq{}
      http.Send (body)

      sendHttpRequest = validateHttpResponse(http)

      If (g\PYGZus{}DEBUG\PYGZus{}OUT And (sendHttpRequest \PYGZlt{}\PYGZgt{} \PYGZdq{}\PYGZdq{})) Then
            Dim size As Long
            size = Len(sendHttpRequest)
            Call MsgBox(sendHttpRequest, , \PYGZdq{}SUCCESS \PYGZhy{} Received \PYGZdq{} \PYGZam{} size \PYGZam{} \PYGZdq{} bytes\PYGZdq{})
      End If
End Function


\PYGZsq{} Returns eihter an empty string if the HTTP response status is not 200 (and display the error message),
\PYGZsq{} or the received content otherwise.
\PYGZsq{}
Function validateHttpResponse(http As Object) As String

      Dim text As String
      Dim resText As String

      Call saveText(g\PYGZus{}TRACE\PYGZus{}FILE, http.responseText)

      resText = saveScreenAndExtractText(g\PYGZus{}SCREEN\PYGZus{}FILE, http.responseText)

      text = getHttpErrorText(http)
      If (text \PYGZlt{}\PYGZgt{} \PYGZdq{}\PYGZdq{}) Then
            text = text \PYGZam{} vbCrLf \PYGZam{} \PYGZdq{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZdq{} \PYGZam{} vbCrLf \PYGZam{} http.responseText
            MsgBox text, , \PYGZdq{}HTTP Request FAILED\PYGZdq{}
            validateHttpResponse = \PYGZdq{}\PYGZdq{}
            Exit Function
      End If

      text = resText
      If (Left(text, 3) = \PYGZdq{}OK:\PYGZdq{}) Then
            text = Mid(text, 4)
            validateHttpResponse = text
            Exit Function
      End If

      If (Left(text, 3) = \PYGZdq{}KO:\PYGZdq{}) Then
            text = \PYGZdq{}Applicative Error :\PYGZdq{} \PYGZam{} vbCrLf \PYGZam{} vbCrLf \PYGZam{} Mid(text, 4)
      Else
            text = text \PYGZam{} vbCrLf \PYGZam{} \PYGZdq{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZdq{} \PYGZam{} vbCrLf \PYGZam{} resText
      End If

      MsgBox text, , \PYGZdq{}Request Failure\PYGZdq{}
      validateHttpResponse = \PYGZdq{}\PYGZdq{}
End Function

\PYGZsq{} Perform a synchronous HTTP request on the specified URL (using the specified body)
\PYGZsq{} If an error occurs, this function returns an empty string.
\PYGZsq{} Otherwise, it returns the body as recieved from the host.
\PYGZsq{}
Function handleHttpResponse(ByVal content As String) As Boolean

      Dim lines() As String
      \PYGZsq{}    Dim line As String
      Dim cell As Range
      Dim idx As Long
      Dim nbLines As Long

      nbLines = extractDataFromResponse(content, lines)

      For Each cell In ActiveSheet.Range(g\PYGZus{}responseRange).cells
      \PYGZsq{}     line = lines(idx)
            If (idx = nbLines) Then Exit For
            Call injectResponseLine(cell, lines(idx))
      \PYGZsq{}     cell.Value = line
            idx = idx + 1
      Next
      handleHttpResponse = True   \PYGZsq{} successful
End Function


Sub injectResponseLine(ByVal cell As Range, line As String)
      Dim col As Long
      Dim row As Long
      row = cell.row
      col = cell.Column

      ActiveSheet.cells(row, col + 0).Value = RTrim(Mid(line, 1, 8))               \PYGZsq{} Name
      ActiveSheet.cells(row, col + 2).Value = LTrim(Mid(line, 20, 8))              \PYGZsq{} Size
      ActiveSheet.cells(row, col + 3).Value = RTrim(Mid(line, 30, 11))             \PYGZsq{} Created
      ActiveSheet.cells(row, col + 4).Value = RTrim(Mid(line, 44, 18))             \PYGZsq{} Changed
      ActiveSheet.cells(row, col + 5).Value = RTrim(Mid(line, 63, 7))              \PYGZsq{} ID
End Sub


\PYGZsq{} Extract the error text from an HTTP object.
\PYGZsq{}

Function getHttpErrorText(http As Object) As String
      If (http.Status = 200) Then \PYGZsq{} Request successful
            getHttpErrorText = \PYGZdq{}\PYGZdq{}
            Exit Function
      End If
      getHttpErrorText = \PYGZdq{}Status code : \PYGZdq{} \PYGZam{} http.Status \PYGZam{} vbCrLf \PYGZus{}
               \PYGZam{} \PYGZdq{}Status text : \PYGZdq{} \PYGZam{} http.statusText
End Function

\PYGZsq{} Append the User/Pass/DSName params to the provided base URL
\PYGZsq{}
\PYGZsq{} TODO : Add some HTML\PYGZhy{}escaping on the extracted value
\PYGZsq{}

Function buildBaseUrl(baseURL As String) As String
      Dim url As String
      Dim host As String
      Dim port As String

      host = LTrim(RTrim(ActiveSheet.Range(g\PYGZus{}virtelHostRange).Value))
      port = LTrim(RTrim(ActiveSheet.Range(g\PYGZus{}virtelPortRange).Value))

      url = \PYGZdq{}http://\PYGZdq{} \PYGZam{} host \PYGZam{} \PYGZdq{}:\PYGZdq{} \PYGZam{} port \PYGZam{} baseURL

      If (InStr(1, baseURL, \PYGZdq{}?\PYGZdq{}) \PYGZlt{} 1) Then
            url = url \PYGZam{} \PYGZdq{}?\PYGZdq{}
      Else
            url = url \PYGZam{} \PYGZdq{}\PYGZam{}\PYGZdq{}
      End If

      url = url \PYGZam{} \PYGZdq{}userName=\PYGZdq{} \PYGZam{} LTrim(RTrim(ActiveSheet.Range(g\PYGZus{}userNameRange).Value))
      url = url \PYGZam{} \PYGZdq{}\PYGZam{}password=\PYGZdq{} \PYGZam{} LTrim(RTrim(ActiveSheet.Range(g\PYGZus{}userPassRange).Value))
      url = url \PYGZam{} \PYGZdq{}\PYGZam{}dsname=\PYGZdq{} \PYGZam{} LTrim(RTrim(ActiveSheet.Range(g\PYGZus{}DSNameRange).Value))
      buildBaseUrl = url
End Function


\PYGZsq{} Extract the \PYGZsq{}URL params\PYGZsq{} from the active sheet, in the specified cells range,
\PYGZsq{} and return them as an URL parameters string.
\PYGZsq{} The parameters extraction stops when the first empty name\PYGZsq{}s cell is encountered.
\PYGZsq{}
\PYGZsq{} TODO : Add some HTML\PYGZhy{}escaping on the extracted value
\PYGZsq{}
Function buildUrlParams(paramsRange As String) As String
      Dim cells As Variant
      Dim res As String, prmName As String
      Dim idx As Long
      Dim sep As String

      cells = ActiveSheet.Range(paramsRange).Value

      For idx = LBound(cells, 1) To UBound(cells, 1)
            prmName = cells(idx, 1)
            If (prmName = \PYGZdq{}\PYGZdq{}) Then Exit For
            res = res \PYGZam{} sep \PYGZam{} prmName \PYGZam{} \PYGZdq{}=\PYGZdq{} \PYGZam{} cells(idx, 2)
            sep = \PYGZdq{}\PYGZam{}\PYGZdq{}
      Next
      buildUrlParams = res
End Function


\PYGZsq{} Merges a base URL and an (optionnal) parameters into a full URL address.
\PYGZsq{}
Function buildURL(ByVal baseURL As String, Optional ByVal params As String = \PYGZdq{}\PYGZdq{}) As String

      Dim separator As String
      If (params \PYGZlt{}\PYGZgt{} \PYGZdq{}\PYGZdq{}) Then
            separator = \PYGZdq{}?\PYGZdq{}
      \PYGZsq{} Do not use \PYGZsq{}?\PYGZsq{} if it is already found in the base URL (in such a case, use \PYGZsq{}\PYGZam{}\PYGZsq{} instead)
      If (InStr(baseURL, \PYGZdq{}?\PYGZdq{}) \PYGZgt{} 0) Then separator = \PYGZdq{}\PYGZam{}\PYGZdq{}
            buildURL = baseURL \PYGZam{} separator \PYGZam{} params
      Else
            buildURL = baseURL
      End If
End Function

\PYGZsq{} Save some text into the specified file.
\PYGZsq{}
Private Sub saveTextOld(ByVal path As String, ByVal content As String)
      On Error GoTo saveTextError
      Dim fso As Object
      Dim file As Object
      Set fso = CreateObject(\PYGZdq{}Scripting.FileSystemObject\PYGZdq{})
      Set file = fso.opentextfile(path, 2, True)
      file.Write content
      file.Close
      Exit Sub

saveTextError:
      On Error GoTo 0
      MsgBox Err.Number \PYGZam{} vbLf \PYGZam{} Err.Description, \PYGZdq{}Trace file saving error\PYGZdq{}
End Sub

Private Sub saveText(ByVal path As String, ByVal content As String)
      On Error GoTo saveTextError
      Dim strFile\PYGZus{}Path As String
      strFile\PYGZus{}Path = path
      Open strFile\PYGZus{}Path For Append As \PYGZsh{}1
      Write \PYGZsh{}1, Now() \PYGZam{} \PYGZdq{} : \PYGZdq{} \PYGZam{} content
      Close \PYGZsh{}1
Exit Sub

saveTextError:
      On Error GoTo 0
      MsgBox Err.Number \PYGZam{} vbLf \PYGZam{} Err.Description, \PYGZdq{}Trace file saving error\PYGZdq{}
End Sub

Private Function saveScreenAndExtractText(ByVal path As String, ByVal content As String) As String
      Dim idx As Long
      idx = InStr(1, content, g\PYGZus{}ScreenTag)
      If (idx \PYGZlt{} 1) Then
      \PYGZsq{} The response does not contain any screen dump
            saveScreenAndExtractText = content
            Exit Function
      End If

      saveScreenAndExtractText = Left(content, idx \PYGZhy{} 1)

      If (Left(content, 3) = \PYGZdq{}KO:\PYGZdq{}) Then
            Sheets(2).Range(g\PYGZus{}ScreenMsgRange).Interior.Color = RGB(255, 255, 64)
            Sheets(2).Range(g\PYGZus{}ScreenMsgRange).Value = \PYGZdq{}  \PYGZdq{} \PYGZam{} Mid(saveScreenAndExtractText, 4)
      End If

      Dim scrData As String
      Dim i As Long
      Dim line As String

      \PYGZsq{} Expected format is:
      \PYGZsq{} (*SCREEN*)\PYGZsh{}01:\PYGZlt{}80 bytes\PYGZgt{}\PYGZsh{}02:\PYGZlt{}80 bytes\PYGZgt{}...\PYGZsh{}24:\PYGZlt{}80 bytes\PYGZgt{}

      idx = idx + Len(g\PYGZus{}ScreenTag) + 4

      For i = 0 To 23
            line = Mid(content, idx + (i * 84), 80)
            Sheets(2).cells(i + g\PYGZus{}ScreenRow, g\PYGZus{}ScreenColumn).Value = line
            scrData = scrData \PYGZam{} line \PYGZam{} vbCrLf
      Next

      Sheets(2).Select
      Sheets(2).Range(g\PYGZus{}ScreenMsgRange).Select

      \PYGZsq{} Save the screen content into the specified trace file
      Call saveText(path, scrData)
End Function

Private Sub ClearScreen()
      Dim i As Integer
      For i = 0 To 23
            Sheets(2).cells(i + g\PYGZus{}ScreenRow, g\PYGZus{}ScreenColumn).ClearContents
      Next
      Sheets(2).Range(g\PYGZus{}ScreenMsgRange).ClearContents
      Sheets(2).Range(g\PYGZus{}ScreenMsgRange).Interior.Color = RGB(255, 255, 255)
End Sub

\PYGZsq{} Clear the specified range of cells
\PYGZsq{}
Sub clearCells(ByVal targetRange As String, Optional ByVal cols As Long = 1)
      Dim cell As Range
      For Each cell In ActiveSheet.Range(targetRange).cells
            cell.ClearContents
            If (cols \PYGZgt{} 1) Then
                  Dim c As Long
                  For c = 2 To cols
                        cells(cell.row, cell.Column + c \PYGZhy{} 1).ClearContents
                  Next
            End If
      Next
End Sub
\end{sphinxVerbatim}



\renewcommand{\indexname}{Index}
\printindex
\end{document}